#include <iostream>
#include <cstdlib>
#include <ctime>
#include <vector>
#include <map>
#include <string>
#include <algorithm>  
#include <cmath>

using namespace std;

class Jugador {
private:
    string nombre;
    int nivelVida;
    string tipoJugador; // "Experto" o "Novato"
    bool rapido;         // true = Rápido, false = Lento
    map<string, float> estadisticasPunteria;
    int equipo;
    int x, y;
    int rangoAtaqueActual;

public:
    // Constructor principal
    Jugador(string _nombre, string _tipo, bool _rapido, int _equipo)
        : nombre(_nombre), tipoJugador(_tipo), rapido(_rapido), nivelVida(3), equipo(_equipo), x(0), y(0), rangoAtaqueActual(1) {
        // Configuración de las probabilidades de puntería
        if (tipoJugador == "Experto") {
            estadisticasPunteria = { {"Torso", 0.60f}, {"Extremidades", 0.35f}, {"Cabeza", 0.05f} };
        }
        else if (tipoJugador == "Novato") {
            estadisticasPunteria = { {"Torso", 0.25f}, {"Extremidades", 0.50f}, {"Cabeza", 0.25f} };
        }
    }

    // Getters
    string obtenerNombre() const { return nombre; }
    int obtenerEquipo() const { return equipo; }
    int obtenerX() const { return x; }
    int obtenerY() const { return y; }
    string getTipoJugador() const { return tipoJugador; }
    bool getRapido() const { return rapido; }
    int getNivelVida() const { return nivelVida; }
    int obtenerRangoAtaqueActual() const { return rangoAtaqueActual; } // Getter para rangoAtaqueActual

    // Setters
    void establecerPosicion(int nuevaX, int nuevaY) { x = nuevaX; y = nuevaY; }

    void reducirVida(int cantidad) {
        nivelVida -= cantidad;
        if (nivelVida < 0) nivelVida = 0;
    }

    string descripcionCompleta() const {
        return getTipoJugador() + (getRapido() ? " Rapido" : " Lento");
    }

    float obtenerProbabilidadPunteria(const string& parteCuerpo) const {
        if (estadisticasPunteria.find(parteCuerpo) != estadisticasPunteria.end()) {
            return estadisticasPunteria.at(parteCuerpo);
        }
        return 0.0f;
    }

    int obtenerCapacidadMovimiento() const {
        if (rapido) {
            float prob = static_cast<float>(rand()) / RAND_MAX;  // 50% de moverse 1 cuadro, 50% de moverse 2 cuadros
            return (prob <= 0.5f) ? 1 : 2;
        }
        else {
            return 1; // Solo pueden moverse 1 cuadro
        }
    }

    void determinarRangoAtaque() {
        if (tipoJugador == "Novato") {
            rangoAtaqueActual = 1; // Solo pueden atacar a una distancia de un cuadro
        }
        else if (tipoJugador == "Experto") {
            float prob = static_cast<float>(rand()) / RAND_MAX; // 50% de atacar a dos cuadros, 50% a uno
            rangoAtaqueActual = (prob <= 0.5f) ? 2 : 1;
        }
    }
};

class Casilla {
private:
    bool tieneBandera;
    string jugador; // Solo un jugador por casilla

public:
    Casilla() : tieneBandera(false), jugador("") {}

    void colocarBandera() { tieneBandera = true; }
    bool esBandera() const { return tieneBandera; }

    bool agregarJugador(const string& nombreJugador) {
        if (jugador.empty()) {
            jugador = nombreJugador;
            return true;
        }
        return false;
    }

    bool removerJugador(const string& nombreJugador) {
        if (jugador == nombreJugador) {
            jugador = "";
            return true;
        }
        return false;
    }

    string obtenerJugador() const { return jugador; }

    bool tieneEspacio() const { return jugador.empty(); }
};

class Equipo {
private:
    string color;
    vector<Jugador> jugadores;

public:
    Equipo(string _color) : color(_color) {}

    void asignarJugadores(int cantidad, int equipoIndex) {
        for (int i = 0; i < cantidad; ++i) {
            string tipo;
            bool esRapido;
            float probabilidad = static_cast<float>(rand()) / RAND_MAX;

            // Tipo de jugador según probabilidades
            if (probabilidad <= 0.15f) {
                tipo = "Experto";
                esRapido = true;
            }
            else if (probabilidad <= 0.40f) {
                tipo = "Experto";
                esRapido = false;
            }
            else if (probabilidad <= 0.65f) {
                tipo = "Novato";
                esRapido = true;
            }
            else {
                tipo = "Novato";
                esRapido = false;
            }

            string nombre = color[0] + to_string(i + 1); // Ej: A1, R1
            jugadores.emplace_back(Jugador(nombre, tipo, esRapido, equipoIndex));
        }
    }

    vector<Jugador>& obtenerJugadores() { return jugadores; }
    const vector<Jugador>& obtenerJugadores() const { return jugadores; }
    string obtenerColor() const { return color; }

    void mostrarEquipo() const {
        cout << "Equipo de color: " << color << endl;
        cout << "Jugadores:" << endl;
        for (const auto& jugador : jugadores) {
            cout << "- " << jugador.obtenerNombre() << " (" << jugador.descripcionCompleta() << ")" << endl;
        }
    }
};

class CampoBatalla {
private:
    vector<vector<Casilla>> casillas;
    int filas;
    int columnas;
    vector<Equipo> equipos;

public:
    CampoBatalla(int m, int n) {
        if (m < 3 || m > 10 || n < 4 || n > 10) {
            throw invalid_argument("El tamano del tablero debe ser de 3x4 a 10x10.");
        }
        filas = m;
        columnas = n + 2; // Aumentamos 2 columnas para las banderas
        casillas = vector<vector<Casilla>>(filas, vector<Casilla>(columnas));
    }

    vector<Equipo>& obtenerEquipos() { return equipos; }

    void agregarEquipos(const vector<string>& colores, int jugadoresPorEquipo) {
        for (int i = 0; i < colores.size(); ++i) {
            Equipo equipo(colores[i]);
            equipo.asignarJugadores(jugadoresPorEquipo, i);
            equipos.push_back(equipo);
        }
    }

    void colocarEquipos() {
        int numEquipos = equipos.size();

        for (int i = 0; i < numEquipos; ++i) {
            vector<Jugador>& jugadores = equipos[i].obtenerJugadores();
            int columnaInicio = (i == 0) ? 1 : columnas - 2;

            for (int j = 0; j < jugadores.size(); ++j) {
                if (j < filas) {
                    // Colocar cada jugador en una fila única
                    if (casillas[j][columnaInicio].agregarJugador(jugadores[j].obtenerNombre())) {
                        jugadores[j].establecerPosicion(j, columnaInicio);
                    }
                    else {
                        cout << "No se pudo colocar al jugador " << jugadores[j].obtenerNombre()
                             << " en la fila " << j << ", columna " << columnaInicio << endl;
                    }
                }
                else {
                    bool colocado = false;
                    for (int k = 0; k < filas; ++k) {
                        if (casillas[k][columnaInicio].agregarJugador(jugadores[j].obtenerNombre())) {
                            jugadores[j].establecerPosicion(k, columnaInicio);
                            colocado = true;
                            break;
                        }
                    }
                    if (!colocado) {
                        cout << "No se pudo colocar al jugador " << jugadores[j].obtenerNombre()
                             << " en la columna " << columnaInicio << endl;
                    }
                }
            }
        }
    }

    void colocarBanderas() {
        for (int i = 0; i < filas; i++) {
            casillas[i][0].colocarBandera();
            casillas[i][columnas - 1].colocarBandera();
        }
    }

    void imprimirTablero() const {
        cout << "Tablero:" << endl;
        for (int i = 0; i < filas; i++) {
            for (int j = 0; j < columnas; j++) {
                if (casillas[i][j].esBandera()) {
                    cout << "[B] ";
                }
                else if (!casillas[i][j].obtenerJugador().empty()) {
                    cout << "[" << casillas[i][j].obtenerJugador() << "] ";
                }
                else {
                    cout << "[ ] ";
                }
            }
            cout << endl;
        }
    }

    void mostrarEquipos() const {
        for (const auto& equipo : equipos) {
            equipo.mostrarEquipo();
        }
    }

    Jugador* buscarJugadorPorNombre(const string& nombreJugador) {
        for (auto& equipo : equipos) {
            for (auto& jugador : equipo.obtenerJugadores()) {
                if (jugador.obtenerNombre() == nombreJugador) {
                    return &jugador;
                }
            }
        }
        return nullptr;
    }

    void imprimirPosiciones() const {
        for (const auto& equipo : equipos) {
            for (const auto& jugador : equipo.obtenerJugadores()) {
                cout << "Jugador " << jugador.obtenerNombre() << " esta en (Fila "
                     << jugador.obtenerX() << ", Columna " << jugador.obtenerY() << ")\n";
            }
        }
    }

    bool moverJugador(const string& nombreJugador, int nuevaX, int nuevaY, int equipoActual) {
        if (nuevaX < 0 || nuevaX >= filas || nuevaY < 0 || nuevaY >= columnas) {
            cout << "Movimiento invalido: fuera de los límites del tablero." << endl;
            return false;
        }

        Jugador* jugador = buscarJugadorPorNombre(nombreJugador);
        if (jugador == nullptr) {
            cout << "Jugador no encontrado." << endl;
            return false;
        }

        if (jugador->obtenerEquipo() != equipoActual) {
            cout << "No puedes mover un jugador del equipo contrario." << endl;
            return false;
        }

        int actualX = jugador->obtenerX();
        int actualY = jugador->obtenerY();

        // Verificar si el movimiento es ortogonal
        int deltaX = abs(nuevaX - actualX);
        int deltaY = abs(nuevaY - actualY);

        if (!((deltaX == 0 && deltaY <= jugador->obtenerCapacidadMovimiento()) ||
              (deltaY == 0 && deltaX <= jugador->obtenerCapacidadMovimiento()))) {
            cout << "Movimiento invalido: solo se permiten movimientos ortogonales de hasta "
                 << jugador->obtenerCapacidadMovimiento() << " cuadro(s)." << endl;
            return false;
        }

        // Verificar que no se mueva a una columna de base
        if (nuevaY == 0 || nuevaY == columnas - 1) {
            cout << "Movimiento invalido: no puedes mover a " << nombreJugador << " a una base (Fila "
                 << nuevaX << ", Columna " << nuevaY << ")." << endl;
            return false;
        }

        if (!casillas[nuevaX][nuevaY].tieneEspacio()) {
            cout << "Movimiento invalido: la casilla (" << nuevaX << ", " << nuevaY << ") esta ocupada." << endl;
            return false;
        }

        casillas[actualX][actualY].removerJugador(nombreJugador);

        casillas[nuevaX][nuevaY].agregarJugador(nombreJugador);
        jugador->establecerPosicion(nuevaX, nuevaY);

        cout << "Jugador " << nombreJugador << " movido a la posicion (" << nuevaX << ", " << nuevaY << ")." << endl;
        return true;
    }

    void atacar(string atacanteNombre, string objetivoNombre, int equipoActual) {
        Jugador* atacante = buscarJugadorPorNombre(atacanteNombre);
        Jugador* objetivo = buscarJugadorPorNombre(objetivoNombre);

        if (atacante == nullptr || objetivo == nullptr) {
            cout << "Atacante u objetivo no encontrado." << endl;
            return;
        }

        if (atacante->obtenerEquipo() != equipoActual) {
            cout << "No puedes atacar con un jugador del equipo contrario." << endl;
            return;
        }

        if (atacante->obtenerEquipo() == objetivo->obtenerEquipo()) {
            cout << "No puedes atacar a un jugador de tu propio equipo." << endl;
            return;
        }

        int ax = atacante->obtenerX();
        int ay = atacante->obtenerY();
        int ox = objetivo->obtenerX();
        int oy = objetivo->obtenerY();

        // Calcular la distancia ortogonal
        int distancia = abs(ax - ox) + abs(ay - oy);

        atacante->determinarRangoAtaque();
        int rangoAtaque = atacante->obtenerRangoAtaqueActual();

        cout << "El rango de ataque de " << atacanteNombre << " es " << rangoAtaque << " espacio(s)." << endl;

        if (distancia <= rangoAtaque) {
            float probabilidad = static_cast<float>(rand()) / RAND_MAX;
            string parteCuerpo;

            float pTorso = atacante->obtenerProbabilidadPunteria("Torso");
            float pExtremidades = pTorso + atacante->obtenerProbabilidadPunteria("Extremidades");

            if (probabilidad <= pTorso) {
                parteCuerpo = "Torso";
                objetivo->reducirVida(1);
            }
            else if (probabilidad <= pExtremidades) {
                parteCuerpo = "Extremidades";
                objetivo->reducirVida(1);
            }
            else {
                parteCuerpo = "Cabeza";
                objetivo->reducirVida(3);
            }

            cout << atacanteNombre << " ataco a " << objetivoNombre << " en el " << parteCuerpo << "." << endl;
            if (objetivo->getNivelVida() <= 0) {
                cout << objetivoNombre << " ha sido eliminado." << endl;
                casillas[ox][oy].removerJugador(objetivoNombre);
            }
        }
        else {
            cout << "El objetivo no esta dentro del rango de ataque." << endl;
        }
    }

    void turnoMaquina(int equipoIndex) {
        vector<Jugador>& jugadores = equipos[equipoIndex].obtenerJugadores();

        // Ver jugadores vivos
        vector<Jugador*> jugadoresVivos;
        for (auto& jugador : jugadores) {
            if (jugador.getNivelVida() > 0) {
                jugadoresVivos.push_back(&jugador);
            }
        }

        if (jugadoresVivos.empty()) {
            cout << "El equipo " << equipos[equipoIndex].obtenerColor() << " no tiene jugadores vivos." << endl;
            return;
        }

        // Seleccionar un jugador aleatorio que esté vivo
        int indiceJugador = rand() % jugadoresVivos.size();
        Jugador* jugadorSeleccionado = jugadoresVivos[indiceJugador];

        bool hizoAccion = false;
        int x = jugadorSeleccionado->obtenerX();
        int y = jugadorSeleccionado->obtenerY();
        vector<Jugador*> objetivos;

        for (auto& equipo : equipos) {
            if (equipo.obtenerColor() == equipos[equipoIndex].obtenerColor()) continue; // Ignorar el propio equipo
            for (auto& jugador : equipo.obtenerJugadores()) {
                if (jugador.getNivelVida() <= 0) continue;
                int ox = jugador.obtenerX();
                int oy = jugador.obtenerY();
                int distancia = abs(x - ox) + abs(y - oy); // Distancia ortogonal
                int rangoAtaque = jugadorSeleccionado->obtenerRangoAtaqueActual();

                jugadorSeleccionado->determinarRangoAtaque();
                rangoAtaque = jugadorSeleccionado->obtenerRangoAtaqueActual();

                if (distancia <= rangoAtaque) {
                    objetivos.push_back(&jugador);
                }
            }
        }

        if (!objetivos.empty()) {
            int indiceObjetivo = rand() % objetivos.size();
            Jugador* jugadorObjetivo = objetivos[indiceObjetivo];
            atacar(jugadorSeleccionado->obtenerNombre(), jugadorObjetivo->obtenerNombre(), equipoIndex);
            hizoAccion = true;
        }

        if (!hizoAccion) {
            int capacidadMovimiento = jugadorSeleccionado->obtenerCapacidadMovimiento();
            vector<pair<int, int>> posicionesPosibles;

            vector<pair<int, int>> direcciones = { {1,0}, {-1,0}, {0,1}, {0,-1} };

            for (const auto& dir : direcciones) {
                for (int paso = 1; paso <= capacidadMovimiento; ++paso) {
                    int nx = x + dir.first * paso;
                    int ny = y + dir.second * paso;
                    if (nx >= 0 && nx < filas && ny >= 0 && ny < columnas && ny != 0 && ny != columnas -1) {
                        if (casillas[nx][ny].tieneEspacio()) {
                            posicionesPosibles.emplace_back(nx, ny);
                        }
                    }
                }
            }

            if (!posicionesPosibles.empty()) {
                int indicePosicion = rand() % posicionesPosibles.size();
                int nuevaX = posicionesPosibles[indicePosicion].first;
                int nuevaY = posicionesPosibles[indicePosicion].second;
                moverJugador(jugadorSeleccionado->obtenerNombre(), nuevaX, nuevaY, equipoIndex);
                cout << "La maquina movio al jugador " << jugadorSeleccionado->obtenerNombre()
                     << " a la posicion (" << nuevaX << ", " << nuevaY << ")." << endl;
                hizoAccion = true;
            }
        }

        if (!hizoAccion) {
            cout << "La maquina no pudo realizar ninguna accion con el jugador " << jugadorSeleccionado->obtenerNombre() << "." << endl;
        }
    }

    bool verificarInicioJuego() {
        for (const auto& equipo : equipos) {
            if (equipo.obtenerJugadores().empty()) {
                cout << "Error: El equipo " << equipo.obtenerColor() << " no tiene jugadores." << endl;
                return false;
            }
        }

        bool banderasColocadas = true;
        for (int i = 0; i < filas; i++) {
            if (!casillas[i][0].esBandera() || !casillas[i][columnas - 1].esBandera()) {
                banderasColocadas = false;
                break;
            }
        }

        if (!banderasColocadas) {
            cout << "Error: Las banderas no estan colocadas correctamente." << endl;
            return false;
        }

        cout << "¡El juego ha iniciado correctamente!" << endl;
        return true;
    }

    bool verificarFinJuego() {
        int equiposConJugadoresVivos = 0;
        string equipoGanador;
        for (const auto& equipo : equipos) {
            bool tieneJugadoresVivos = false;
            for (const auto& jugador : equipo.obtenerJugadores()) {
                if (jugador.getNivelVida() > 0) {
                    tieneJugadoresVivos = true;
                    break;
                }
            }
            if (tieneJugadoresVivos) {
                equiposConJugadoresVivos++;
                equipoGanador = equipo.obtenerColor();
            }
        }
        if (equiposConJugadoresVivos <= 1) {
            cout << "El equipo " << equipoGanador << " ha ganado el juego." << endl;
            return true;
        }
        return false;
    }
};

class Turno {
private:
    int turnoActual; // 0 o 1

public:
    Turno() : turnoActual(0) {}

    int getTurnoActual() const { return turnoActual; }

    void cambiarTurno() { turnoActual = (turnoActual == 0) ? 1 : 0; }

    string getEquipoActualColor() const { return (turnoActual == 0) ? "Azul" : "Rojo"; }
};

int main() {
    srand(static_cast<unsigned int>(time(0)));

    string modoJuego;
    cout << "Selecciona el modo de juego (aleatorio/estandar): ";
    cin >> modoJuego;

    transform(modoJuego.begin(), modoJuego.end(), modoJuego.begin(), ::tolower);

    int filas, columnas;
    int jugadoresPorEquipo;

    if (modoJuego == "aleatorio") {
        filas = rand() % 8 + 3;
        columnas = rand() % 7 + 4;
        jugadoresPorEquipo = filas;
        cout << "Modo aleatorio seleccionado. Tamano del tablero: " << filas << "x" << columnas
             << ". Jugadores por equipo: " << jugadoresPorEquipo << endl;
    }
    else {
        filas = 4;
        columnas = 5;
        jugadoresPorEquipo = filas;
        cout << "Modo estandar seleccionado. Tamano del tablero: " << filas << "x" << (columnas + 2)
             << ". Jugadores por equipo: " << jugadoresPorEquipo << endl;
    }

    try {
        CampoBatalla batalla(filas, columnas);

        vector<string> colores = { "Azul", "Rojo" };
        batalla.agregarEquipos(colores, jugadoresPorEquipo);

        string equipoHumanoColor;
        cout << "Selecciona tu equipo (Azul/Rojo): ";
        cin >> equipoHumanoColor;

        transform(equipoHumanoColor.begin(), equipoHumanoColor.end(), equipoHumanoColor.begin(), ::tolower);

        int equipoHumano, equipoMaquina;
        if (equipoHumanoColor == "azul") {
            equipoHumano = 0;
            equipoMaquina = 1;
        }
        else if (equipoHumanoColor == "rojo") {
            equipoHumano = 1;
            equipoMaquina = 0;
        }
        else {
            cout << "Color de equipo invalido. Se asignara el equipo Azul por defecto." << endl;
            equipoHumano = 0;
            equipoMaquina = 1;
        }

        batalla.colocarEquipos();
        batalla.colocarBanderas();

        batalla.imprimirTablero();
        batalla.imprimirPosiciones();
        batalla.mostrarEquipos();

        if (!batalla.verificarInicioJuego()) {
            return 1;
        }

        Turno turno;
        bool juegoTerminado = false;
        while (!juegoTerminado) {
            cout << "\nTurno del equipo: " << turno.getEquipoActualColor() << endl;

            batalla.imprimirTablero();
            batalla.imprimirPosiciones();

            if (turno.getTurnoActual() == equipoHumano) {
                string accion;
                cout << "Selecciona accion (mover/atacar): ";
                cin >> accion;

                transform(accion.begin(), accion.end(), accion.begin(), ::tolower);

                if (accion == "mover") {
                    string nombreJugador;
                    int nuevaX, nuevaY;
                    cout << "Nombre del jugador a mover: ";
                    cin >> nombreJugador;

                    Jugador* jugador = batalla.buscarJugadorPorNombre(nombreJugador);
                    if (jugador == nullptr) {
                        cout << "Jugador no encontrado. Intenta nuevamente." << endl;
                        continue;
                    }

                    int capacidadMovimiento = jugador->obtenerCapacidadMovimiento();
                    cout << "El jugador " << nombreJugador << " puede moverse hasta " << capacidadMovimiento << " espacio(s)." << endl;

                    cout << "Nueva posicion (fila columna): ";
                    cin >> nuevaX >> nuevaY;

                    if (batalla.moverJugador(nombreJugador, nuevaX, nuevaY, turno.getTurnoActual())) {
                        cout << "Jugador " << nombreJugador << " movido exitosamente." << endl;
                    }
                    else {
                        cout << "Movimiento invalido." << endl;
                    }
                }
                else if (accion == "atacar") {
                    string atacante, objetivo;
                    cout << "Nombre del atacante: ";
                    cin >> atacante;

                    Jugador* jugadorAtacante = batalla.buscarJugadorPorNombre(atacante);
                    if (jugadorAtacante == nullptr) {
                        cout << "Atacante no encontrado. Intenta nuevamente." << endl;
                        continue;
                    }

                    jugadorAtacante->determinarRangoAtaque();
                    int rangoAtaque = jugadorAtacante->obtenerRangoAtaqueActual();
                    cout << "El jugador " << atacante << " tiene un rango de ataque de " << rangoAtaque << " espacio(s)." << endl;

                    cout << "Nombre del objetivo: ";
                    cin >> objetivo;

                    batalla.atacar(atacante, objetivo, turno.getTurnoActual());
                }
                else {
                    cout << "Accion no valida. Por favor, elige 'mover' o 'atacar'." << endl;
                }
            }
            else {
                cout << "La maquina esta tomando su turno..." << endl;
                batalla.turnoMaquina(equipoMaquina);
            }

            juegoTerminado = batalla.verificarFinJuego();
            if (!juegoTerminado) {
                turno.cambiarTurno();
            }
        }

    }
    catch (const invalid_argument& e) {
        cerr << "Error: " << e.what() << endl;
        return 1;
    }

    return 0;
}
